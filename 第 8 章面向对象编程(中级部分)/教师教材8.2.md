### 8.5 访问修饰符

在 Java 程序设计中，访问修饰符是实现封装特性的核心工具，它能够精确控制类、成员变量（属性）和成员方法的可访问范围。合理运用访问修饰符，既能保障代码的安全性，防止无关代码的非法篡改，又能提高程序的可维护性，明确代码的职责边界。本节将系统讲解 Java 中的访问修饰符及其使用规范。

#### 8.5.1 基本概念与分类

Java 提供了四种访问控制修饰符，它们根据访问范围从大到小依次为：

1. **public（公开级别）**
   被`public`修饰的类、属性或方法，具有最广泛的访问权限。无论其他类与当前类是否在同一个包中，也无论是否存在继承关系，都可以直接访问。例如，Java 核心类库中的`System`类及其`out.println()`方法，就是用`public`修饰的，因此能在任何地方调用。
2. **protected（受保护级别）**
   `protected`修饰的成员（属性或方法），其访问范围包括两个场景：一是当前类所在包中的所有类；二是当前类的子类（无论子类与父类是否在同一个包中）。这一特性常用于父类向子类暴露需要继承的核心功能，同时限制非子类的访问。
3. **默认级别（无修饰符）**
   当类、属性或方法未使用任何访问修饰符时，即为默认级别。其访问范围仅限当前类所在的包，不同包中的类（即使是子类）也无法访问。这种级别适用于包内部的协作类，避免外部包的无关代码干扰。
4. **private（私有级别）**
   `private`是访问权限最严格的修饰符，被它修饰的成员只能在当前类内部被访问，其他任何类（包括同一包中的类和子类）都无法直接访问。这是封装的核心体现，用于隐藏类的内部实现细节，仅通过公开方法与外部交互。

#### 8.5.2 访问范围对比

为了直观理解四种修饰符的访问范围，我们通过表格梳理不同场景下的访问权限（表 8-1）：

| 访问修饰符 | 同一类内部 | 同一包中的非子类 | 不同包中的子类 | 不同包中的非子类 |
| ---------- | ---------- | ---------------- | -------------- | ---------------- |
| public     | ✅ 可访问   | ✅ 可访问         | ✅ 可访问       | ✅ 可访问         |
| protected  | ✅ 可访问   | ✅ 可访问         | ✅ 可访问       | ❌ 不可访问       |
| 默认级别   | ✅ 可访问   | ✅ 可访问         | ❌ 不可访问     | ❌ 不可访问       |
| private    | ✅ 可访问   | ❌ 不可访问       | ❌ 不可访问     | ❌ 不可访问       |

**关键说明**：

- 表格中 “✅” 表示允许访问，“❌” 表示禁止访问；
- 类的访问修饰符仅支持`public`和默认级别，`protected`和`private`不能修饰类；
- 子类访问父类的`protected`成员时，需通过子类对象或子类内部的`super`关键字（而非父类对象）访问。

#### 8.5.3 代码示例与解析

下面通过具体代码示例，验证不同访问修饰符的使用规则。

##### 示例 1：定义包含四种修饰符的类 A

```java
package com.hspedu.modifier;

/**
 * 演示四种访问修饰符修饰的成员在类内部的访问规则
 */
public class A {
    // 四种修饰符修饰的成员变量
    public int n1 = 100;        // 公开级别
    protected int n2 = 200;     // 受保护级别
    int n3 = 300;               // 默认级别（无修饰符）
    private int n4 = 400;       // 私有级别

    // 四种修饰符修饰的成员方法
    public void m1() {
        // 类内部可访问所有修饰符的成员变量
        System.out.println("n1=" + n1 + "，n2=" + n2 + "，n3=" + n3 + "，n4=" + n4);
    }

    protected void m2() {}      // 受保护方法

    void m3() {}                // 默认方法

    private void m4() {}        // 私有方法

    public void testInternalAccess() {
        // 类内部可访问所有修饰符的成员方法
        m1();
        m2();
        m3();
        m4();
    }
}
```

**解析**：在类 A 内部，无论是`public`、`protected`、默认级别还是`private`修饰的成员（变量和方法），都可以被直接访问。这是因为类自身对内部成员拥有完全访问权限。

##### 示例 2：同一包中的类 B 访问类 A 的成员

```java
package com.hspedu.modifier;

/**
 * 与类A同包，演示同包类对A成员的访问规则
 */
public class B {
    public void accessA() {
        A a = new A();  // 创建类A的实例

        // 访问成员变量
        System.out.println("public变量n1：" + a.n1);   // 允许
        System.out.println("protected变量n2：" + a.n2); // 允许
        System.out.println("默认变量n3：" + a.n3);     // 允许
        // System.out.println("private变量n4：" + a.n4); // 错误：private成员不可访问

        // 访问成员方法
        a.m1();  // 允许访问public方法
        a.m2();  // 允许访问protected方法
        a.m3();  // 允许访问默认方法
        // a.m4();  // 错误：private方法不可访问
    }
}
```

**解析**：类 B 与类 A 位于同一包（`com.hspedu.modifier`），因此可以访问 A 中`public`、`protected`和默认级别的成员，但`private`成员被严格限制在 A 内部，无法访问。

##### 示例 3：不同包中的子类 C 访问类 A 的成员

```java
package com.hspedu.modifier.sub;  // 与A不同包

import com.hspedu.modifier.A;

/**
 * 类A的子类，与A不同包，演示跨包子类的访问规则
 */
public class C extends A {
    public void accessParent() {
        // 访问父类成员变量（通过子类实例或super）
        System.out.println("父类public变量n1：" + n1);   // 允许
        System.out.println("父类protected变量n2：" + n2); // 允许（子类内部）
        // System.out.println("父类默认变量n3：" + n3);   // 错误：跨包默认成员不可访问
        // System.out.println("父类private变量n4：" + n4); // 错误：private成员不可访问

        // 访问父类成员方法
        m1();  // 允许访问public方法
        m2();  // 允许访问protected方法（子类内部）
        // m3();  // 错误：跨包默认方法不可访问
        // m4();  // 错误：private方法不可访问
    }

    public void accessParentByObject() {
        A a = new A();  // 创建父类实例
        // System.out.println(a.n2);  // 错误：跨包时不能通过父类对象访问protected成员
    }
}
```

**解析**：类 C 是 A 的子类且位于不同包，因此可以访问 A 的`public`成员和`protected`成员（但`protected`成员只能在 C 内部通过自身实例或`super`访问，不能通过父类对象访问）；默认级别和`private`成员仍不可访问。

##### 示例 4：不同包中的非子类 D 访问类 A 的成员

```java
package com.hspedu.modifier.other;  // 与A不同包

import com.hspedu.modifier.A;

/**
 * 与类A不同包且非子类，演示跨包非子类的访问规则
 */
public class D {
    public void accessA() {
        A a = new A();

        // 仅能访问public成员
        System.out.println("public变量n1：" + a.n1);  // 允许
        a.m1();  // 允许访问public方法

        // 以下均不允许访问
        // System.out.println(a.n2);  // protected成员
        // System.out.println(a.n3);  // 默认成员
        // System.out.println(a.n4);  // private成员
        // a.m2(); a.m3(); a.m4();
    }
}
```

**解析**：类 D 与 A 既不同包也无继承关系，因此只能访问 A 中`public`修饰的成员，其他级别成员均不可访问。

##### 示例 5：测试类的访问修饰符

```java
package com.hspedu.modifier;

// public类：可被所有包访问，类名必须与文件名一致（如TestModifier.java）
public class TestModifier {
    public static void main(String[] args) {
        A a = new A();
        a.testInternalAccess();  // 调用A的内部测试方法

        B b = new B();
        b.accessA();  // 调用同包类B的访问方法

        // 如需测试类C和D，需导入对应包并创建实例
        // com.hspedu.modifier.sub.C c = new com.hspedu.modifier.sub.C();
        // c.accessParent();
    }
}

// 默认类：仅能被同包类访问
class DefaultClass {
    // 类成员...
}
```

**解析**：`TestModifier`是`public`类，可被项目中所有类访问；`DefaultClass`是默认类，仅能被`com.hspedu.modifier`包中的类访问。

#### 8.5.4 使用注意事项

1. **修饰符的选择原则**
   - 优先使用`private`：隐藏类的内部状态（如成员变量）和实现细节（如辅助方法），仅通过`public`方法提供对外接口；
   - 谨慎使用`protected`：仅在需要被子类继承时使用，避免过度暴露；
   - 合理使用默认级别：用于包内部的协作类或成员，减少跨包依赖；
   - 控制`public`范围：仅将必须公开的功能声明为`public`，降低耦合度。
2. **类的修饰限制**
   - 一个`.java`文件中最多有一个`public`类，且类名必须与文件名相同；
   - 内部类（嵌套在其他类中的类）可以使用`protected`和`private`修饰，外部类则不行。
3. **子类重写的权限规则**
   子类重写父类方法时，重写方法的访问权限不能低于父类方法（例如，父类方法是`protected`，子类重写时只能是`protected`或`public`，不能是默认级别或`private`）。

#### 总结

访问修饰符是 Java 实现封装的关键机制，通过控制成员的可访问范围，确保了代码的安全性和模块化。掌握`public`、`protected`、默认级别和`private`的访问规则，能帮助我们设计出更健壮、易维护的程序。在实际开发中，应根据 “最小权限原则” 选择合适的修饰符，即只暴露必要的功能，隐藏不必要的细节。

### 基于 BOPPPS 模型的 “Java 访问修饰符” 课程流程设计

#### 一、Bridge-in（导入，5 分钟）

“同学们在使用手机时，会不会给相册设置隐私权限？比如部分照片仅自己可见，部分允许好友查看，还有些会公开到社交平台 —— 其实这种‘权限控制’的思维，在 Java 编程中同样重要。假设你写了一个学生信息管理系统，其中‘成绩’需要加密，‘姓名’可以公开查询，‘家庭住址’仅允许管理员（子类）查看，该如何实现这种精细化控制？今天要学的‘访问修饰符’，就是 Java 为我们提供的‘权限管理工具’，让我们一起揭开它的神秘面纱。”

#### 二、Objective（学习目标，3 分钟）

1. 能准确说出 Java 中四种访问修饰符的名称及定义；
2. 能通过表格对比分析四种修饰符的访问范围差异；
3. 能结合代码案例判断不同场景下成员的可访问性；
4. 能根据实际需求为类、属性和方法选择合适的访问修饰符。

#### 三、Pre-assessment（前测，7 分钟）

1. 提问：“大家之前写过的类中，成员变量和方法是否加过修饰符？为什么这么加？”（引导学生回忆已有认知）
2. 快速判断：“如果一个属性被`private`修饰，在同一个类的方法中能访问吗？不同包的类呢？”（通过朴素认知暴露盲区，为后续讲解铺垫）

#### 四、Participatory Learning（参与式学习，30 分钟）

1. **初识修饰符：从 “隐私等级” 到 “权限分类”**
   “刚才我们提到手机隐私的三级权限，Java 其实有更细致的四级控制。就像管理一个图书馆：`public`是开放阅读区（所有人可进），`protected`是教师借阅区（本校老师和学生可进），默认级别是本楼层阅览区（同楼层读者可进），`private`是馆长办公室（仅馆长可用）。”
   结合教材中的基本介绍，逐一讲解`public`、`protected`、默认级别、`private`的定义，用 “图书馆分区” 类比加深理解。
2. **范围对比：用 “场景测试” 突破难点**
   “光说不练假把式，我们来做个‘权限挑战赛’。”
   展示教材表 8-1，以 “同一类→同一包非子类→不同包子类→不同包非子类” 为线索，结合类 A（含四种修饰符成员）的案例，让学生分组判断：
   - 类 A 的方法能访问 n4 吗？（引出 “同一类内无限制”）
   - 同包类 B 能调用 A 的 m4 () 吗？（引出`private`的严格限制）
   - 不同包子类 C 能访问 A 的 n3 吗？（引出默认级别的包内限制）
     每组派代表说明判断依据，教师结合代码运行结果订正，同步标注表格中 “✅”“❌” 的由来。
3. **代码实操：从 “看懂” 到 “会用”**
   “现在请大家当一回‘系统设计师’，为一个‘银行账户类’设计权限：”
   - 账户余额（balance）：仅本类的`getBalance()`方法可访问→用`private`；
   - 开户行（bank）：同包的转账类可查看→用默认级别；
   - 利息计算方法（calcInterest）：仅子类（如储蓄账户、信用账户）可重写→用`protected`；
   - 账户状态查询（getStatus）：所有类可调用→用`public`。
     学生编写代码后，同桌互换检查，教师选取典型案例投屏点评，强化 “按需选择修饰符” 的思维。

#### 五、Post-assessment（后测，10 分钟）

1. 案例分析：给出类 D（不同包非子类）访问类 A 成员的代码，让学生找出错误并说明原因（考查跨包访问规则）；
2. 情景选择：“如果要让一个方法既能被同包类访问，又能被不同包的子类访问，该用哪种修饰符？”（巩固`protected`的特性）；
3. 综合判断：展示教材中类 C（不同包子类）的代码，判断哪些语句合法（检验子类访问规则的掌握程度）。

#### 六、Summary（总结，5 分钟）

“今天我们一起搭建了 Java 的‘权限管理系统’：从‘图书馆分区’认识了四种修饰符，通过‘场景测试’理清了访问范围，最后用‘银行账户设计’学会了实际应用。记住，选择修饰符的核心是‘最小权限原则’—— 就像给重要文件设密码，够用就好，不必过度开放。下节课我们将学习‘封装’，而访问修饰符正是封装的‘核心密码’，大家可以提前思考：如何用今天学的知识隐藏类的内部细节？”

## 课后练习

### 一、选择题

1. Java 中，以下哪个访问修饰符的访问范围最广？（ ）
   A. private
   B. protected
   C. public
   D. 默认级别
2. 被 protected 修饰的成员，在以下哪种场景中可以被访问？（ ）
   A. 不同包中的非子类
   B. 同一包中的非子类
   C. 任何场景
   D. 仅同一类内部
3. 以下关于默认级别（无修饰符）成员的说法，正确的是（ ）
   A. 可以被不同包的子类访问
   B. 只能被同一类内部访问
   C. 可以被同一包中的所有类访问
   D. 可以被任何类访问
4. 下列哪种访问修饰符不能用于修饰类？（ ）
   A. public
   B. protected
   C. 默认级别
   D. 以上都可以
5. 在同一个类中，以下哪种修饰符修饰的成员不能被访问？（ ）
   A. private
   B. protected
   C. public
   D. 以上都能被访问
6. 子类重写父类的方法时，重写方法的访问权限不能（ ）父类方法的访问权限。
   A. 高于
   B. 低于
   C. 等于
   D. 以上都不对
7. 若类 A 和类 B 在同一个包中，类 A 有一个 private 成员 n，那么类 B 中（ ）
   A. 可以直接访问 n
   B. 只能通过类 A 的 public 方法访问 n
   C. 可以通过继承访问 n
   D. 以上都不对
8. 以下代码中，能正常编译的是（ ）

```java
package pkg1;
public class A { protected int x = 10; }

package pkg2;
import pkg1.A;
public class B extends A {
    public void test() { System.out.println(x); }
}
```

A. 编译错误，因为 x 是 protected 成员
B. 编译正确，输出 10
C. 编译错误，因为 B 和 A 不在同一包
D. 编译错误，需要通过 super 访问 x

1. 以下关于 private 修饰符的说法，错误的是（ ）
   A. 被 private 修饰的成员只能在本类内部访问
   B. 子类不能继承父类的 private 成员
   C. 同一包中的其他类可以访问 private 成员
   D. private 是访问权限最严格的修饰符
2. 若要让一个成员能被同一包中的类和不同包的子类访问，但不能被不同包的非子类访问，应使用的修饰符是（ ）
   A. public
   B. protected
   C. 默认级别
   D. private

### 二、填空题

1. Java 中四种访问修饰符从访问范围由大到小依次为：public、______、默认级别、private。
2. 被______修饰的成员，只能在当前类内部被访问。
3. 类的访问修饰符只能是 public 或______。
4. 同一包中的类，可以访问 public、protected 和______修饰的成员。
5. 不同包中的子类，可以访问父类的 public 和______修饰的成员。
6. 一个 Java 源文件中最多有______个 public 类，且类名必须与文件名相同。
7. 子类重写父类方法时，重写方法的访问权限不能______父类方法的访问权限。
8. 若成员变量被 private 修饰，其他类只能通过该类提供的______方法间接访问。
9. 被默认级别修饰的成员，其访问范围仅限于______。
10. 访问修饰符是实现 Java______特性的核心工具。

### 三、判断题

1. public 修饰的成员可以被任何类访问。（ ）
2. protected 修饰的成员在不同包的非子类中可以被访问。（ ）
3. 类可以被 private 修饰。（ ）
4. 同一类内部可以访问所有修饰符修饰的成员。（ ）
5. 默认级别成员的访问范围比 protected 小。（ ）
6. 子类可以通过父类对象访问父类的 protected 成员。（ ）
7. private 修饰的成员不能被继承。（ ）
8. 不同包中的非子类只能访问 public 修饰的成员。（ ）
9. 一个 Java 源文件中可以有多个默认级别类。（ ）
10. 访问修饰符的选择应遵循 “最大权限原则”。（ ）

### 四、简答题

1. 简述 Java 中四种访问修饰符的访问范围。
2. 为什么说访问修饰符是实现封装的核心工具？
3. 子类重写父类方法时，对访问权限有什么要求？为什么？
4. 同一包中的类和不同包中的子类，对 protected 成员的访问有何区别？
5. 类的访问修饰符有哪些限制？
6. 什么是 “最小权限原则”？在选择访问修饰符时如何体现？
7. 若要设计一个工具类，其中的方法需要被所有类调用，应使用哪种修饰符？为什么？
8. 为什么 private 修饰的成员不能被其他类直接访问？这有什么好处？
9. 对比默认级别和 protected 修饰符的异同点。
10. 举例说明如何根据实际需求选择合适的访问修饰符。

### 五、编程题

1. 定义一个类`Student`，包含私有属性`name`和`age`，以及 public 的`setName`、`getName`、`setAge`、`getAge`方法，实现对属性的封装。
2. 定义类`Parent`（包`pkg1`），包含 protected 方法`show()`；定义类`Child`（包`pkg2`）继承`Parent`，在`Child`中编写方法调用`show()`。
3. 定义类`A`（包`pkg`），包含默认级别属性`num`；定义类`B`（同包`pkg`），在`B`中创建`A`的对象并访问`num`。
4. 编写代码验证：不同包的非子类无法访问 protected 成员。
5. 定义类`Test`，其中包含四种修饰符的属性和方法，在类内部编写方法访问所有成员，观察是否编译通过。
6. 定义类`Animal`（包`animal`），包含 private 方法`eat()`和 public 方法`run()`；定义类`Dog`（同包），尝试调用`Animal`的`eat()`和`run()`，观察结果。
7. 设计一个`BankAccount`类，要求：账号（`accountId`）公开访问，余额（`balance`）仅本类和子类访问，交易记录（`record`）仅本包访问，密码（`password`）仅本类访问。
8. 编写代码验证：子类重写父类方法时，访问权限不能低于父类方法。
9. 定义类`C`（包`p1`）和类`D`（包`p2`），`D`不是`C`的子类，在`D`中尝试访问`C`的默认级别成员，观察编译结果。
10. 综合运用四种访问修饰符设计一个简单的图书管理类`Book`，包含书名（公开）、作者（同包可见）、库存（子类可见）、定价（仅本类可见），并编写测试类验证访问规则。

### 参考答案及解析

#### 一、选择题

1. C
   解析：public 的访问范围最广，可被任何类访问。
2. B
   解析：protected 成员可被同一包中的类（包括非子类）和不同包的子类访问。
3. C
   解析：默认级别成员的访问范围仅限同一包中的所有类。
4. B
   解析：类只能被 public 或默认级别修饰，protected 和 private 不能修饰类。
5. D
   解析：同一类内部对所有修饰符的成员都有访问权限。
6. B
   解析：子类重写方法的权限不能低于父类，否则会缩小访问范围，违反继承的开放性。
7. B
   解析：private 成员仅本类可直接访问，其他类需通过该类的 public 方法间接访问。
8. B
   解析：子类在自身方法中可直接访问父类的 protected 成员，无需通过 super（除非有重名）。
9. C
   解析：private 成员仅限本类访问，同一包的其他类也无法访问。
10. B
    解析：protected 符合 “同一包 + 不同包子类可访问，不同包非子类不可访问” 的需求。

#### 二、填空题

1. protected
2. private
3. 默认级别（无修饰符）
4. 默认级别
5. protected
6. 1
7. 低于
8. public（或公开）
9. 同一包
10. 封装

解析：填空题主要考查访问修饰符的基本定义、范围及使用规则，需准确记忆核心概念。

#### 三、判断题

1. √
   解析：public 的访问范围是全局，任何类都可访问。
2. ×
   解析：protected 成员在不同包的非子类中不可访问。
3. ×
   解析：类不能被 private 修饰，仅能被 public 或默认级别修饰。
4. √
   解析：同一类内部对所有成员有完全访问权限。
5. √
   解析：默认级别仅限同一包，protected 还包括不同包子类，因此默认级别范围更小。
6. ×
   解析：子类需通过自身实例或 super 访问父类的 protected 成员，不能通过父类对象。
7. √
   解析：private 成员不参与继承，子类无法获取。
8. √
   解析：不同包非子类的访问权限仅限于 public 成员。
9. √
   解析：一个源文件可包含多个默认级别类，仅 public 类有数量限制。
10. ×
    解析：应遵循 “最小权限原则”，即仅暴露必要的访问范围。

#### 四、简答题

1. 答：

- public：可被任何类访问（同一类、同一包、不同包子类、不同包非子类）。
- protected：可被同一类、同一包的类、不同包的子类访问，不可被不同包的非子类访问。
- 默认级别：可被同一类、同一包的类访问，不可被不同包的类（包括子类）访问。
- private：仅可被同一类内部访问，其他任何类都不可访问。

1. 答：封装的核心是 “隐藏内部细节，暴露必要接口”。访问修饰符通过控制成员的访问范围，实现了对内部状态（如 private 属性）的隐藏，仅通过 public 方法与外部交互，从而保障数据安全和代码模块化。
2. 答：子类重写父类方法时，重写方法的访问权限不能低于父类方法。原因是：如果子类方法权限更低，会导致 “父类对象调用子类方法时权限突然缩小”，违反继承的一致性原则，降低代码可维护性。
3. 答：相同点：两者都能访问 protected 成员。不同点：同一包中的类可通过父类对象访问 protected 成员；不同包的子类只能在自身方法中通过自身实例或 super 访问，不能通过父类对象访问。
4. 答：类的访问修饰符仅限 public 和默认级别；一个 Java 源文件中最多有一个 public 类，且类名必须与文件名一致；默认级别类仅能被同一包的类访问。
5. 答：“最小权限原则” 指在满足功能需求的前提下，选择访问范围最小的修饰符。例如：仅本类使用的成员用 private，同包协作的用默认级别，需被子类继承的用 protected，全局访问的用 public。这能减少外部干扰，提高代码安全性。
6. 答：应使用 public 修饰符。因为工具类的方法需要被所有类调用，public 的全局访问范围可满足这一需求，确保任何包、任何类都能直接使用。
7. 答：private 成员的访问被限制在本类内部，是为了隐藏类的内部实现细节（如数据校验逻辑）。好处：防止外部类直接修改数据导致错误，提高代码的可维护性和安全性，符合封装思想。
8. 答：相同点：两者都能被同一类和同一包的类访问。不同点：protected 还能被不同包的子类访问，默认级别则不能；默认级别仅限同一包，protected 的范围更广。
9. 答：例如设计 “用户类”：

- 用户名（username）需要公开显示，用 public；
- 家庭地址（address）仅允许同包的 “地址管理类” 访问，用默认级别；
- 会员等级（level）需要被子类（如 VIP 用户）继承，用 protected；
- 登录密码（password）仅本类的验证方法使用，用 private。

#### 五、编程题答案及解析

1. **Student 类封装实现**
   **答案代码**：

   ```java
   public class Student {
       private String name;
       private int age;
   
       public void setName(String name) {
           this.name = name;
       }
   
       public String getName() {
           return name;
       }
   
       public void setAge(int age) {
           this.age = age;
       }
   
       public int getAge() {
           return age;
       }
   }
   ```
   
   **解析**：
   用`private`修饰`name`和`age`，确保属性无法被外部直接修改；通过`public`的`setter`（设置值）和`getter`（获取值）方法实现对属性的间接访问。这种设计符合封装思想，后续可在`setter`中添加校验逻辑（如年龄不能为负数），增强代码安全性。
   
2. **跨包子类访问 protected 方法**
   **答案代码**：

   ```java
   // 包pkg1
   package pkg1;
   public class Parent {
       protected void show() {
           System.out.println("Parent's show()");
       }
   }
   
   // 包pkg2
   package pkg2;
   import pkg1.Parent;
   public class Child extends Parent {
       public void test() {
           show(); // 直接调用父类的protected方法
       }
   
       public static void main(String[] args) {
           new Child().test(); // 输出：Parent's show()
       }
   }
   ```
   
   **解析**：
   `Parent`的`show()`方法被`protected`修饰，`Child`作为不同包的子类，在自身方法中可直接访问该方法。这体现了`protected`的核心作用：允许子类继承并使用父类的核心功能，同时限制非子类的访问。
   
3. **同包类访问默认级别成员**
   **答案代码**：

   ```java
   // 包pkg
   package pkg;
   public class A {
       int num = 100; // 默认级别（无修饰符）
   }
   
   // 同包pkg
   package pkg;
   public class B {
       public static void main(String[] args) {
           A a = new A();
           System.out.println(a.num); // 输出：100
       }
   }
   ```
   
   **解析**：
   类`A`的`num`为默认级别，其访问范围仅限同一包。类`B`与`A`同包，因此可直接访问`num`。默认级别适用于包内协作场景，避免外部包的无关类干扰，同时简化包内类的交互。
   
4. **验证不同包非子类无法访问 protected 成员**
   **答案代码**：

   ```java
   // 包p1
   package p1;
   public class X {
       protected void method() {}
   }
   
   // 包p2（非子类）
   package p2;
   import p1.X;
   public class Y {
       public static void main(String[] args) {
           X x = new X();
           // x.method(); // 编译错误：不同包非子类无法访问protected成员
       }
   }
   ```
   
   **解析**：
   `X`的`method()`为`protected`，类`Y`与`X`不同包且无继承关系，因此`Y`中通过`X`对象调用`method()`会编译报错。这验证了`protected`的访问限制：仅允许同一包类和不同包子类访问，其他场景均不可访问。
   
5. **类内部访问所有修饰符成员**
   **答案代码**：

   ```java
   public class Test {
       public int a = 1;
       protected int b = 2;
       int c = 3;
       private int d = 4;
   
       public void accessAll() {
           System.out.println(a + b + c + d); // 输出：10
       }
   
       public static void main(String[] args) {
           new Test().accessAll();
       }
   }
   ```
   
   **解析**：
   类`Test`内部定义了四种修饰符的属性，其方法`accessAll()`可正常访问所有属性并输出总和 10。这说明**同一类对自身成员拥有完全访问权限**，不受任何访问修饰符的限制。
   
6. **同包类访问 private 和 public 成员**
   **答案代码**：

   ```java
   // 包animal
   package animal;
   public class Animal {
       private void eat() {
           System.out.println("Eating");
       }
       public void run() {
           System.out.println("Running");
       }
   }
   
   // 同包animal
   package animal;
   public class Dog {
       public static void main(String[] args) {
           Animal animal = new Animal();
           // animal.eat(); // 编译错误：private方法仅限本类访问
           animal.run(); // 输出：Running
       }
   }
   ```
   
   **解析**：
   `Animal`的`eat()`为`private`，即使`Dog`与`Animal`同包，也无法直接调用；`run()`为`public`，`Dog`可正常访问。体现了`private`的严格封装性 —— 隐藏类的内部实现细节（如 “吃” 的具体逻辑），仅通过`public`方法（如 “跑”）对外暴露必要功能。
   
7. **BankAccount 类权限设计**
   **答案代码**：

   ```java
   public class BankAccount {
       public String accountId; // 公开访问（账号可对外展示）
       protected double balance; // 本类和子类访问（余额允许子类扩展）
       String record; // 同包访问（交易记录仅本包对账类使用）
       private String password; // 仅本类访问（密码绝对私有）
   }
   ```
   
   **解析**：
   根据成员的敏感程度和访问需求选择修饰符：
   
   - `accountId`用`public`：允许外部查询账号；
   - `balance`用`protected`：支持子类（如`CreditAccount`）扩展余额计算逻辑；
   - `record`用默认级别：限制仅本包的交易管理类访问；
   - `password`用`private`：仅本类的密码验证方法可使用，最大化安全性。
     完全符合 “最小权限原则”。
   
8. **子类重写方法的权限限制**
   **答案代码**：

   ```java
   class Father {
       protected void func() {}
   }
   
   class Son extends Father {
       // public void func() {} // 正确：权限高于父类（public > protected）
       // protected void func() {} // 正确：权限等于父类
       // void func() {} // 编译错误：权限低于父类（默认级别 < protected）
   }
   ```
   
   **解析**：
   子类重写父类方法时，重写方法的访问权限不能低于父类方法。若父类方法为`protected`，子类方法只能是`protected`或`public`；若使用默认级别或`private`，则会编译报错。这一规则确保继承的一致性，避免 “父类可访问的方法，子类反而不可访问” 的矛盾。
   
9. **不同包非子类访问默认级别成员**
   **答案代码**：

   ```java
   // 包p1
   package p1;
   public class C {
       int value = 5; // 默认级别
   }
   
   // 包p2
   package p2;
   import p1.C;
   public class D {
       public static void main(String[] args) {
           C c = new C();
           // System.out.println(c.value); // 编译错误：不同包非子类无法访问默认级别成员
       }
   }
   ```
   
   **解析**：
   默认级别成员的访问范围仅限同一包，类`D`与`C`不同包且非子类，因此无法访问`value`，编译时会提示 “`value` has default access in `p1.C`”。这验证了默认级别 “包内可见” 的特性。
   
10. **Book 类综合权限设计**
    **答案代码**：

    ```java
    // 图书类
    public class Book {
        public String bookName; // 公开（书名可任意查询）
        String author; // 同包可见（作者信息仅本包管理类修改）
        protected int stock; // 子类可见（库存允许子类调整）
        private double price; // 仅本类可见（定价为内部机密）
    
        public Book(String bookName, String author, int stock, double price) {
            this.bookName = bookName;
            this.author = author;
            this.stock = stock;
            this.price = price;
        }
    
        private void printPrice() { // 仅本类访问定价
            System.out.println("内部定价：" + price);
        }
    
        public void showBasicInfo() {
            System.out.println("书名：" + bookName + "，作者：" + author);
            printPrice(); // 本类内部调用private方法
        }
    }
    
    // 同包测试类（验证默认级别访问）
    package samepkg; // 与Book同包
    public class SamePackageTest {
        public static void main(String[] args) {
            Book book = new Book("Java编程", "张三", 100, 59.9);
            System.out.println(book.author); // 正确：同包访问默认级别成员
        }
    }
    
    // 不同包子类（验证protected访问）
    package subpkg;
    import samepkg.Book;
    public class Ebook extends Book {
        public Ebook(String bookName, String author, int stock, double price) {
            super(bookName, author, stock, price);
        }
        public void checkStock() {
            System.out.println("库存：" + stock); // 正确：子类访问protected成员
        }
    }
    
    // 不同包非子类（验证public访问）
    package otherpkg;
    import samepkg.Book;
    public class OtherPackageTest {
        public static void main(String[] args) {
            Book book = new Book("Java编程", "张三", 100, 59.9);
            System.out.println(book.bookName); // 正确：访问public成员
            // System.out.println(book.author); // 错误：不同包无法访问默认级别
            // System.out.println(book.stock); // 错误：不同包非子类无法访问protected
        }
    }
    ```
    
    **解析**：
    该设计综合运用四种修饰符，根据图书信息的敏感程度分层控制访问：
    
    - 书名（`bookName`）公开，满足基本查询需求；
    - 作者（`author`）仅限同包修改，确保信息管理权限；
    - 库存（`stock`）允许子类（如`Ebook`）调整，支持业务扩展；
    - 定价（`price`）完全私有，保护商业机密。
      三个测试类分别验证了不同场景下的访问规则，全面体现了访问修饰符的实际应用价值。