# 8.6 面向对象编程三大特征

## 8.6.1 基本介绍

面向对象编程（Object-Oriented Programming，OOP）的核心思想，通过 **封装、继承、多态** 三大特征，实现对现实世界问题的抽象建模，让程序设计更贴近人类思维习惯，提升代码的可维护性、可扩展性与复用性。

## 8.6.2 封装介绍

### 概念定义

**封装（Encapsulation）** 是面向对象编程的基础特征之一，指将抽象出的 **数据（属性）** 与对数据的 **操作（方法）** 绑定为一个整体（类），并对数据进行访问限制：数据被隐藏在类的内部，程序其他部分需通过类提供的 **授权方法**（如 `get`/`set` 方法 ），才能合法操作数据。

### 类比理解

可将封装类比为 “手机的设置界面”：

- 手机的 “电量数值” 是 **属性**，“充电逻辑、耗电计算” 是 **方法**，它们共同封装在 “手机类” 中；
- 用户无需了解 “电量如何计算”（隐藏实现细节），只需通过 “设置界面的电量显示、充电按钮”（授权方法）操作电量。

## 8.6.3 封装的理解和好处

### 1. 隐藏实现细节，降低复杂度

- **原理**：将类的内部逻辑（如数据库连接、复杂算法）封装在方法中，外部仅需调用方法，无需了解实现过程。

- 示例

  ：

  ```java
  public class DBUtil {
      // 隐藏数据库连接细节（用户名、密码、驱动类名）
      private String dbUrl = "jdbc:mysql://localhost:3306/test";
      private String dbUser = "root";
      private String dbPwd = "123456";
  
      // 对外提供简化的连接方法
      public Connection getConnection() {
          // 复杂的连接逻辑封装在此
          return DriverManager.getConnection(dbUrl, dbUser, dbPwd);
      }
  }
  ```

  外部调用

  ```
  getConnection()
  ```

  即可获取数据库连接，无需关心

  ```
  dbUrl
  ```

  等细节。

### 2. 保护数据安全，实现逻辑校验

- **原理**：通过封装限制属性的直接访问，在 `set` 方法中添加校验逻辑，确保数据合法、安全。

- **示例**：
  若直接开放 `age` 属性，可能出现不合理赋值：

  ```java
  class Person {
      // 直接暴露属性，风险高
      public int age; 
  }
  
  // 外部错误调用
  Person p = new Person();
  p.age = 1200; // 年龄赋值为1200，不符合现实逻辑
  ```

  通过封装修复问题：

  ```java
  class Person {
      // 私有化属性，禁止直接访问
      private int age; 
  
      // 提供set方法，加入校验逻辑
      public void setAge(int age) {
          if (age >= 0 && age <= 150) { // 限制合理范围
              this.age = age;
          } else {
              System.out.println("年龄需在0-150之间，赋值失败");
          }
      }
  
      // 提供get方法，获取属性值
      public int getAge() {
          return age;
      }
  }
  
  // 外部调用
  Person p = new Person();
  p.setAge(1200); // 输出提示：年龄需在0-150之间，赋值失败
  ```

## 8.6.4 封装的实现步骤（三步）

### 1. 私有化属性（隐藏数据）

使用 **`private` 访问修饰符** 修饰类的属性，禁止外部直接访问，确保数据只能通过类的方法操作。

```java
class Student {
    // 私有化属性，外部无法直接修改
    private String name; 
    private int score; 
}
```

### 2. 提供公共 `set` 方法（赋值 + 校验）

定义 **`public` 修饰的 `setXxx()` 方法**（`Xxx` 为属性名），用于接收外部数据，并在方法内添加 **业务逻辑校验**（如数据范围、格式验证 ），确保属性赋值合法。

```java
class Student {
    private String name;
    private int score; 

    // setName方法：校验姓名非空
    public void setName(String name) {
        if (name != null && !name.trim().isEmpty()) { 
            this.name = name;
        } else {
            System.out.println("姓名不能为空");
        }
    }

    // setScore方法：校验分数范围（0-100）
    public void setScore(int score) {
        if (score >= 0 && score <= 100) { 
            this.score = score;
        } else {
            System.out.println("分数需在0-100之间");
        }
    }
}
```

### 3. 提供公共 `get` 方法（获取数据）

定义 **`public` 修饰的 `getXxx()` 方法**（`Xxx` 为属性名），用于向外部返回属性的值。若需控制数据访问权限（如 “管理员可查看，普通用户隐藏” ），可在 `get` 方法中添加逻辑判断。

```java
class Student {
    private String name;
    private int score; 

    // get方法：无复杂逻辑时直接返回属性
    public String getName() {
        return name;
    }

    public int getScore() {
        return score;
    }
}
```

### 完整示例：封装的 Student 类

```java
class Student {
    // 1. 私有化属性
    private String name;
    private int score; 

    // 2. set方法：带校验逻辑
    public void setName(String name) {
        if (name != null && !name.trim().isEmpty()) {
            this.name = name;
        } else {
            System.out.println("姓名不能为空");
        }
    }

    public void setScore(int score) {
        if (score >= 0 && score <= 100) {
            this.score = score;
        } else {
            System.out.println("分数需在0-100之间");
        }
    }

    // 3. get方法：返回属性值
    public String getName() {
        return name;
    }

    public int getScore() {
        return score;
    }
}

// 测试封装
public class TestEncapsulation {
    public static void main(String[] args) {
        Student stu = new Student();
        stu.setName(""); // 输出：姓名不能为空
        stu.setScore(150); // 输出：分数需在0-100之间

        stu.setName("张三");
        stu.setScore(95);
        System.out.println("姓名：" + stu.getName() + "，分数：" + stu.getScore()); 
        // 输出：姓名：张三，分数：95
    }
}
```

### 总结

封装通过 “**隐藏属性 + 开放方法**” 的设计，实现了数据的安全管理与逻辑复用：

- 对开发者：降低代码耦合度，隐藏复杂实现，让类的职责更清晰；
- 对调用者：无需关心内部细节，只需通过简单方法操作类，提升开发效率。
  后续章节将学习 “继承” 与 “多态”，进一步体会面向对象编程的强大能力。

# 《面向对象编程三大特征之封装》BOPPPS 教学流程设计

## 一、Bridge-in（导入，5 分钟）

同学们，咱们每天用手机 app 时，比如购物软件里的 “下单” 功能，你知道背后是怎么运作的吗？其实就像把 “商品数据” 和 “下单逻辑” 打包在一起，这和咱们今天要学的面向对象编程里超重要的 “封装” 概念特别像！想象一下，要是 app 里的 “用户余额” 能被随便改，那岂不是乱套啦？这就得靠封装来守护数据安全。接下来咱们就一起揭开 “封装” 的神秘面纱，看看它咋让程序又安全又好用！

## 二、Objective（学习目标，3 分钟）

1. 能精准说清封装的定义，明白它在面向对象编程里的核心作用。
2. 掌握封装 “隐藏细节、保护数据” 的好处，会用代码案例验证。
3. 熟练按照 “私有化属性、写 set/get 方法” 三步，完成类的封装实操。
4. 能结合生活场景（像手机 app、银行账户），分析封装的实际应用。

## 三、Pre-assessment（前测，5 分钟）

1. 提问互动：大家之前写类的时候，属性是直接用 `public` 暴露，还是有别的处理？为啥这么做呀？（引导回忆，暴露对封装的初始认知 ）
2. 快速判断：看这段代码，`public class Person { public int age; }` ，要是直接给 `age` 赋值 1200 ，合理不？能怎么改进？（用朴素问题，引出封装需求 ）

## 四、Participatory Learning（参与式学习，25 分钟）

### （一）概念拆解：从生活到代码理解封装（7 分钟）

**生活类比**：拿咱们常用的外卖软件举例，“订单金额计算” 就是隐藏的逻辑（对应封装的 “方法”），“收货地址、餐品信息” 是数据（对应封装的 “属性”），它们打包在 “订单类” 里，咱们下单时只用点按钮（调用方法），不用操心咋算钱、咋配送。

**代码定义**：那编程里的封装，就是把类的 **属性（数据）** 和 **操作属性的方法** 绑一起，用 `private` 把数据藏起来，只开放 `get/set` 这些授权方法给外部操作。就像给数据加了个 “安全屋”，想进得走正门（授权方法）！

### （二）好处探究：隐藏细节 + 保护数据（8 分钟）

#### 1. 隐藏实现细节 —— 以 “数据库连接” 为例

**代码演示**：

```java
public class DBHelper {
    private String url = "jdbc:mysql://..."; // 隐藏连接地址
    private String user = "root"; // 隐藏用户名

    public Connection getConn() {
        // 这里写复杂的连接逻辑，外部不用懂
        return DriverManager.getConnection(url, user, "123"); 
    }
}
```

**互动提问**：要是把 `url`、`user` 改成 `public` 直接暴露，会有啥问题？（引导答：暴露敏感信息、逻辑被篡改 ）所以封装把这些细节藏起来，外部调用 `getConn()` 就能用，多方便！

#### 2. 保护数据安全 —— 以 “Person 类年龄校验” 为例

**错误案例**：先看没封装的代码

```java
class Person {
    public int age; 
}
// 外部调用
Person p = new Person();
p.age = 1200; // 年龄乱赋值，不合理！
```

**封装修复**：用三步封装解决

```java
class Person {
    private int age; 

    public void setAge(int age) {
        if (age >= 0 && age <= 150) { // 校验逻辑
            this.age = age;
        } else {
            System.out.println("年龄得在 0 - 150 之间！");
        }
    }

    public int getAge() {
        return age;
    }
}
// 测试
Person p = new Person();
p.setAge(1200); // 输出提示，赋值失败，保护数据啦！
```

**小组讨论**：对比两种写法，说说封装咋保护数据安全的？（派代表答：通过 `set` 方法的校验，拦住不合理数据 ）

### （三）实操落地：封装的 “三步实现法”（10 分钟）

**分步讲解 + 代码实操**：

#### 1. 第一步：私有化属性（`private` 修饰）

就像给属性锁上 “小房间”，外部不能直接碰。比如学生类的姓名、分数：

```java
class Student {
    private String name; // 姓名藏起来
    private int score; // 分数藏起来
}
```

#### 2. 第二步：写 `set` 方法（赋值 + 校验）

给外部开 “正门”，还能在门里设关卡（校验逻辑）。比如给 `name` 加非空校验，给 `score` 加 0 - 100 范围校验：

```java
public void setName(String name) {
    if (name != null && !name.trim().isEmpty()) { 
        this.name = name;
    } else {
        System.out.println("姓名不能空！");
    }
}

public void setScore(int score) {
    if (score >= 0 && score <= 100) { 
        this.score = score;
    } else {
        System.out.println("分数得 0 - 100 ！");
    }
}
```

#### 3. 第三步：写 `get` 方法（获取属性值）

让外部能合法拿到数据，简单返回属性就行：

```java
public String getName() {
    return name;
}

public int getScore() {
    return score;
}
```

**课堂练习**：现在大家自己动手，把 `Student` 类按这三步封装，写完同桌互相调用测试，看看校验逻辑咋生效的！（老师巡视指导 ）

## 五、Post-assessment（后测，7 分钟）

1. **选择题**：以下关于封装的说法，正确的是（ ）
   A. 封装就是把所有属性都设为 `public`
   B. `set` 方法只能赋值，不能加校验
   C. 封装能隐藏细节、保护数据安全
   D. `get` 方法不能返回 `private` 属性的值
   （答案：C ，解析：A 错在封装是用 `private` 隐藏；B 错在 `set` 可加校验；D 错在 `get` 就是用来返回 `private` 属性的 ）
2. **代码改错题**：找出这段代码封装的问题并修复

```java
class User {
    public String id; 

    private void setId(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }
}
```

（问题：`id` 用 `public` 暴露，`setId` 用 `private` 外部没法调用；修复：`id` 改 `private` ，`setId` 改 `public` ）

1. **场景应用题**：设计一个 “银行账户类（BankAccount）”，要求：账户余额（balance）不能直接修改，只能通过 `deposit`（存款）、`withdraw`（取款）方法操作，且取款时要校验余额是否足够。用封装实现！（提示：`balance` 设 `private` ，写 `getBalance` ，再写 `deposit`、`withdraw` 方法加逻辑 ）

## 六、Summary（总结，5 分钟）

咱们今天从生活里的外卖、手机 app ，一路学到代码里的封装：

- 定义：把属性和方法打包，用 `private` 藏数据，开放 `get/set` 操作；
- 好处：藏细节（像数据库连接逻辑）、保安全（像年龄校验）；
- 实操：三步走 —— 私有化属性、写带校验的 `set` 、写 `get` 。

封装就像给程序数据建了个 “安全城堡”，守护着数据的合理与安全！下节课咱们接着学面向对象的另一个大招 ——“继承”，看看咋让类之间传承功能，更高效编程！

# 课后练习

## 一、选择题

1. 面向对象编程三大特征不包括以下哪个？（ ）
   A. 封装
   B. 继承
   C. 多态
   D. 抽象
2. 关于封装的描述，正确的是（ ）
   A. 封装就是把所有属性都定义为`public`
   B. 封装后外部类不能访问类的任何成员
   C. 封装通过`private`隐藏属性，提供`get/set`方法供外部访问
   D. `set`方法只能用于赋值，不能添加任何逻辑
3. 以下实现封装的步骤，正确顺序是（ ）
   ①提供公共的`get`方法获取属性值
   ②将属性私有化（`private`修饰）
   ③提供公共的`set`方法赋值并校验
   A. ①②③
   B. ②③①
   C. ③②①
   D. ②①③
4. 封装的主要好处不包括（ ）
   A. 隐藏实现细节，降低外部使用复杂度
   B. 可以对数据进行验证，保证数据安全合理
   C. 让所有属性都能被外部直接修改，方便操作
   D. 提高代码的可维护性和安全性
5. 若一个类的属性被`private`修饰，以下说法正确的是（ ）
   A. 外部类可以直接访问该属性
   B. 外部类只能通过此类的`get/set`方法访问
   C. 子类可以直接访问该属性
   D. 同一包中的类可以直接访问
6. 以下代码中，体现封装思想的是（ ）

```java
class Person {
    private String name;
    public void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
}
```

A. 没有体现，因为`name`是`private`但`set/get`太简单
B. 体现了，通过`private`隐藏`name`，`set/get`控制访问
C. 没有体现，封装需要更复杂的逻辑
D. 体现了，`name`是`private`就代表封装

1. 在封装中，`set`方法的主要作用是（ ）
   A. 仅用于获取属性的值
   B. 用于给属性赋值，且可添加数据校验逻辑
   C. 只能赋值，不能做任何判断
   D. 是`private`方法，外部不能调用
2. 关于封装的 “隐藏实现细节”，以下示例最符合的是（ ）
   A. 把类的属性用`private`修饰
   B. 在`set`方法里判断年龄是否合理
   C. 把数据库连接的`url`、用户名等隐藏在类内部，提供`getConnection`方法
   D. 写一个`get`方法返回属性值
3. 以下场景中，适合用封装解决的是（ ）
   A. 让所有变量都能被外部随意修改
   B. 隐藏 “用户密码加密逻辑”，只开放`setPassword`方法做加密处理
   C. 不需要校验数据，直接暴露属性
   D. 让类的所有方法都公开
4. 子类继承父类时，对于父类中`private`封装的属性，子类（ ）
   A. 可以直接访问
   B. 可以通过父类的`get/set`方法访问
   C. 不能访问，因为`private`完全隐藏
   D. 只有`protected`修饰的子类能访问

## 二、填空题

1. 面向对象编程三大特征是______、***\**\*、\*\**\*** 。
2. 封装的核心是把抽象出的______和对数据的操作______封装在一起，数据被保护在内部。
3. 封装实现的第一步是将属性进行______（用`private`修饰 ），目的是______ 。
4. `set`方法的访问修饰符通常是______，用于______属性并可添加______ ；`get`方法用于______属性的值。
5. 封装能让程序隐藏______，比如把数据库连接的复杂逻辑藏在方法里；还能对数据进行______，保证数据合理。
6. 编写一个类时，若属性是`private String name;` ，对应的`set`方法格式一般是`public void setName(String name) { … }` ，`get`方法格式是______ 。
7. 封装体现了面向对象编程 “______” 的思想，把数据和操作数据的逻辑打包管理。
8. 当外部类要访问被封装的`private`属性时，必须通过该类提供的______方法。
9. 在`set`方法中，常见的逻辑是对传入的参数进行______，比如判断年龄是否在 0 - 150 之间。
10. 从代码安全性角度，封装能防止外部类______修改属性值，避免数据混乱。

## 三、判断题

1. 封装就是把所有属性都设为`private`，所有方法都设为`public`。（ ）
2. 只要类中有`private`属性，就一定实现了封装。（ ）
3. 封装后的`set`方法只能用来赋值，不能添加任何逻辑判断。（ ）
4. 子类可以直接访问父类中被`private`封装的属性。（ ）
5. 封装能隐藏实现细节，比如把 “计算商品总价” 的复杂逻辑藏在方法里。（ ）
6. `get`方法的作用是返回属性的值，所以不需要任何逻辑，直接返回即可。（ ）
7. 面向对象编程三大特征的封装、继承、多态，封装是基础。（ ）
8. 封装后的类，外部可以通过`private`属性名直接访问属性。（ ）
9. 在`set`方法中添加数据校验，是封装 “保护数据安全” 的体现。（ ）
10. 封装的实现步骤可以简化为：私有化属性→写`get`方法→写`set`方法。（ ）

## 四、简答题

1. 简述封装的定义和核心思想。
2. 说明封装的 “隐藏实现细节” 和 “保护数据安全” 两个好处，各举一个代码示例。
3. 详细描述封装的实现步骤，以及每一步的作用。
4. 为什么说封装能提高代码的可维护性？结合 “修改数据校验逻辑” 场景说明。
5. 对比 “未封装直接暴露属性” 和 “封装后通过`get/set`访问” 两种方式，分析优缺点。
6. 举例说明生活中的 “封装” 现象，如何对应到编程中的封装思想。
7. 子类继承父类时，父类封装的`private`属性对子类访问有什么影响？子类如何访问这些属性？
8. 在`set`方法中，除了数据范围校验，还能添加哪些逻辑来保证数据安全？（至少举 2 例 ）
9. 封装体现了面向对象编程的什么设计原则？简要解释。
10. 若要设计一个 “电商订单类（Order）”，包含订单金额、收货地址等属性，说明如何用封装设计，并说明每个步骤的考虑。

## 五、编程题

1. 设计一个`Person`类，包含`name`（姓名）、`age`（年龄）属性，用封装实现：
   - 姓名不能为空（`setName`方法校验）；
   - 年龄在 0 - 150 之间（`setAge`方法校验）；
   - 提供`get`方法获取属性值。
2. 编写`Student`类，属性有`studentId`（学号，字符串类型）、`score`（分数，0 - 100），实现封装：
   - 学号设置时去除首尾空格；
   - 分数设置时校验范围，不合法则提示并赋值失败；
   - 提供`get`方法。
3. 定义`BankAccount`类，属性`balance`（余额，double 类型），要求：
   - 不能直接修改余额，只能通过`deposit`（存款，增加余额）和`withdraw`（取款，减少余额，需校验余额是否足够）方法操作；
   - 提供`getBalance`方法查看余额。
4. 设计`Rectangle`类，属性`width`（宽度）、`height`（高度），封装要求：
   - 宽度和高度必须大于 0；
   - 提供`getArea`方法计算矩形面积（面积 = 宽 × 高 ），隐藏计算逻辑；
   - 提供`get`和`set`方法。
5. 编写`User`类，包含`username`（用户名，长度 6 - 20）、`password`（密码，至少 8 位）属性，用封装实现：
   - `setUsername`校验长度，不合法提示；
   - `setPassword`校验长度，不合法提示；
   - 提供`get`方法。
6. 定义`Product`类，属性`name`（商品名）、`price`（价格，大于 0）、`stock`（库存，大于等于 0），实现封装：
   - 各属性`set`方法添加对应校验；
   - 提供`get`方法；
   - 写一个`reduceStock`方法（减少库存，需校验库存是否足够减少 ）。
7. 设计`Car`类，属性`brand`（品牌）、`speed`（时速，0 - 200），封装要求：
   - 品牌设置时转成首字母大写格式（如输入 “bmw” 转成 “Bmw” ）；
   - 时速`set`方法校验范围；
   - 提供`get`方法。
8. 编写`ScoreRecord`类，属性`mathScore`（数学成绩，0 - 100）、`chineseScore`（语文成绩，0 - 100），实现封装：
   - 各科目成绩`set`方法校验范围；
   - 提供`getTotalScore`方法计算总分（隐藏计算逻辑 ）；
   - 提供`get`方法。
9. 定义`Address`类，属性`province`（省份）、`city`（城市）、`detail`（详细地址），封装要求：
   - 省份和城市设置时去除多余空格；
   - 提供`getFullAddress`方法拼接完整地址（如 “四川省 成都市 某某街道” ）；
   - 提供`get`和`set`方法。
10. 设计`Temperature`类，属性`value`（温度值，-273.15 - 1000 之间，模拟现实合理范围 ），实现封装：
    - `set`方法校验温度范围；
    - 提供`get`方法；
    - 写一个`isBoiling`方法判断是否达到沸点（100℃，简单判断 ），隐藏判断逻辑。

# 参考答案及解析部分

## 一、选择题答案及解析

1. **答案**：D
   **解析**：面向对象编程三大特征是封装、继承、多态，“抽象” 是面向对象分析设计中的概念，并非三大特征之一 。
2. **答案**：C
   **解析**：A 错，封装是用`private`隐藏属性；B 错，封装后可通过`get/set`访问；D 错，`set`可加校验逻辑，如年龄判断 。
3. **答案**：B
   **解析**：封装三步是先私有化属性，再写`set`方法赋值校验，最后写`get`方法获取，顺序为②③① 。
4. **答案**：C
   **解析**：封装的核心是限制外部直接修改属性，C 选项 “让所有属性都能被外部直接修改” 违背封装思想 。
5. **答案**：B
   **解析**：`private`修饰的属性，外部类只能通过类的`get/set`方法访问，A、C、D 选项描述错误 。
6. **答案**：B
   **解析**：该代码通过`private`隐藏`name`，用`set/get`控制访问，符合封装思想，A、C、D 对封装理解片面 。
7. **答案**：B
   **解析**：`set`方法用于给属性赋值，且可添加如数据范围、格式等校验逻辑，A 是`get`作用，C、D 描述错误 。
8. **答案**：C
   **解析**：A 是私有化属性步骤；B 是数据校验；D 是`get`方法作用；C 把数据库连接细节隐藏，提供`getConnection`方法，符合 “隐藏实现细节” 。
9. **答案**：B
   **解析**：A、C、D 都违背封装思想，B 通过`setPassword`隐藏加密逻辑，符合封装 “隐藏细节、保护数据” 。
10. **答案**：B
    **解析**：父类`private`属性子类不能直接访问，但可通过父类的`get/set`方法访问，A、C、D 描述错误 。

## 二、填空题答案及解析

1. **答案**：封装、继承、多态
   **解析**：面向对象编程三大核心特征，需准确记忆 。
2. **答案**：数据（属性）、方法
   **解析**：封装把 “数据” 和 “操作数据的方法” 绑定，保护数据内部访问 。
3. **答案**：私有化、防止外部直接访问属性，为数据安全做基础
   **解析**：第一步用`private`隐藏属性，避免外部随意修改，是封装的基础 。
4. **答案**：`public`、给属性赋值、数据校验逻辑、获取
   **解析**：`set`是`public`供外部调用赋值，可加校验；`get`用于返回属性值 。
5. **答案**：实现细节、验证（校验）
   **解析**：封装隐藏如 “数据库连接、复杂计算” 等细节，通过`set`方法校验数据 。
6. **答案**：`public String getName() { return name; }`
   **解析**：`get`方法返回对应属性，格式为`public + 返回类型 + getXxx() { return xxx; }` 。
7. **答案**：高内聚（或 “数据与操作绑定” ）
   **解析**：封装体现 “高内聚” 设计，把数据和操作逻辑紧密结合 。
8. **答案**：`public`的`get/set`（或 “授权的`public`方法” ）
   **解析**：外部访问`private`属性，必须通过类提供的`public`方法 。
9. **答案**：校验（验证、判断等 ）
   **解析**：`set`方法常对参数做合法性校验，保证数据合理 。
10. **答案**：随意（直接、无限制等 ）
    **解析**：封装限制外部直接修改属性，避免数据因随意赋值混乱 。

## 三、判断题答案及解析

1. **答案**：×
   **解析**：封装不是简单把属性设`private`、方法设`public`，而是合理隐藏和开放，且方法也可根据需求设不同权限 。
2. **答案**：×
   **解析**：仅有`private`属性不算完整封装，需配合`get/set`方法控制访问，否则属性无法被外部合理使用 。
3. **答案**：×
   **解析**：`set`方法核心作用之一就是添加数据校验、格式处理等逻辑，并非只能赋值 。
4. **答案**：×
   **解析**：父类`private`属性子类不能直接访问，需通过父类`get/set`方法 。
5. **答案**：√
   **解析**：把 “计算商品总价” 等复杂逻辑藏在方法里，外部只需调用，符合 “隐藏实现细节” 。
6. **答案**：×
   **解析**：`get`方法也可添加逻辑，比如判断是否有权限返回属性值，不只是直接返回 。
7. **答案**：√
   **解析**：封装是面向对象编程基础，通过隐藏和开放，为继承、多态提供数据安全和逻辑复用支持 。
8. **答案**：×
   **解析**：封装后`private`属性外部不能直接访问，必须通过`get/set` 。
9. **答案**：√
   **解析**：`set`方法加数据校验，能拦截非法数据，保证数据安全，是封装核心好处 。
10. **答案**：×
    **解析**：封装步骤是 “私有化属性→写`set`方法（赋值校验）→写`get`方法（获取）”，顺序不能错 。

## 四、简答题答案及解析

1. **简述封装的定义和核心思想**
   **答案**：
   封装是面向对象编程的基础特征，核心是把类的**属性（数据）\**与操作属性的\**方法**封装为一个整体 。通过`private`修饰属性隐藏内部数据，仅开放`public`的`get/set`等方法，让外部按规则访问数据，实现 “隐藏细节、保护数据安全”。

**解析**：
抓住 “数据 + 方法绑定”“隐藏（`private`）+ 开放（`get/set`）” 两个核心，说明封装如何隔离内部实现与外部访问。

1. **说明封装的 “隐藏实现细节” 和 “保护数据安全” 两个好处，各举一个代码示例**
   **答案**：

- **隐藏实现细节**：
  把复杂逻辑（如数据库连接、算法）藏在方法里，外部无需了解细节。
  示例（数据库连接类）：

  ```java
  public class DBHelper {
      // 隐藏连接细节（敏感信息、复杂逻辑）
      private String dbUrl = "jdbc:mysql://localhost:3306/test"; 
      private String dbUser = "root";  
  
      // 对外暴露简化方法
      public Connection getConnection() { 
          // 复杂的连接逻辑封装在此，外部只需调用
          return DriverManager.getConnection(dbUrl, dbUser, "123456"); 
      }
  }
  ```

  外部调用`getConnection()`即可获取连接，无需关心`dbUrl`等细节。

- **保护数据安全**：
  通过`set`方法校验数据，防止非法赋值。
  示例（Person 类年龄校验）：

  ```java
  class Person {
      private int age; 
  
      public void setAge(int age) {
          // 校验年龄范围，非法数据不赋值
          if (age >= 0 && age <= 150) { 
              this.age = age;
          } else {
              System.out.println("年龄需在0-150之间！");
          }
      }
  }
  ```

  外部调用`setAge(1200)`时，因校验拦截非法数据，保证数据合理。

**解析**：
“隐藏细节” 强调 “内部逻辑不暴露”，用数据库连接案例体现；“保护数据” 强调 “校验拦截非法值”，用年龄赋值案例体现，代码需清晰展示封装的作用。

1. **详细描述封装的实现步骤，以及每一步的作用**
   **答案**：
   封装分三步实现，作用依次为：

- **① 私有化属性（`private`修饰）**：
  用`private`隐藏类的属性，禁止外部直接访问。
  作用：切断外部对数据的 “直接修改路径”，为数据安全打基础。
  示例：

  ```java
  class Student {
      private String name; // 私有化，外部不能直接改name
  }
  ```

- **② 提供公共`set`方法（赋值 + 校验）**：
  定义`public`的`setXxx()`方法，接收外部数据，**添加校验逻辑**（如数据范围、格式）。
  作用：控制属性赋值的合法性，过滤非法数据。
  示例：

  ```java
  public void setName(String name) {
      // 校验姓名非空
      if (name != null && !name.trim().isEmpty()) { 
          this.name = name;
      } else {
          System.out.println("姓名不能为空！");
      }
  }
  ```

- **③ 提供公共`get`方法（获取数据）**：
  定义`public`的`getXxx()`方法，返回属性值。
  作用：允许外部 “合法获取” 数据，若需权限控制（如管理员可见），可在`get`中加逻辑。
  示例：

  ```java
  public String getName() {
      return name; // 返回name的值
  }
  ```

**解析**：
每一步需说明 “怎么做（代码）” 和 “为什么做（作用）”，突出 “私有化切断直接访问→`set`控制赋值→`get`开放读取” 的完整逻辑。

1. **为什么说封装能提高代码的可维护性？结合 “修改数据校验逻辑” 场景说明**
   **答案**：
   封装通过 “集中管理数据访问逻辑” 提高可维护性。若需修改校验规则（如调整年龄范围），只需修改`set`方法内部逻辑，**外部调用代码无需改动**。

示例：
原`Person`类`setAge`校验 “0-150”：

```java
public void setAge(int age) {
    if (age >= 0 && age <= 150) { 
        this.age = age;
    }
}
```

若需求变更为 “0-120”，只需修改`setAge`方法：

```java
public void setAge(int age) {
    if (age >= 0 && age <= 120) { // 仅修改此处
        this.age = age;
    }
}
```

外部调用`p.setAge(110)`的代码无需任何调整，因为封装把 “校验逻辑” 集中在`set`方法里，修改范围可控。

**解析**：
核心逻辑是 “变化点集中”—— 封装让数据校验逻辑收拢在`set`方法，修改时不影响外部代码，体现 “高内聚、低耦合” 的可维护性。

1. **对比 “未封装直接暴露属性” 和 “封装后通过`get/set`访问” 两种方式，分析优缺点**
   **答案**：

| 方式               | 优点                                                         | 缺点                                                         |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 未封装（暴露属性） | 实现简单，外部可直接读写属性                                 | 数据无保护，易被非法赋值（如年龄设为 1200）； 修改逻辑需改动外部代码（耦合性高） |
| 封装（`get/set`）  | 数据安全（`set`校验拦截非法值）； 逻辑集中，修改方便（如改校验规则只需动`set`） | 实现稍复杂，需写`get/set`方法                                |

示例：

- 未封装：

  ```java
  class Person {
      public int age; // 直接暴露
  }
  // 外部可直接赋值非法数据
  Person p = new Person();
  p.age = 1200; 
  ```

- 封装后：

  ```java
  class Person {
      private int age; 
      public void setAge(int age) {
          if (age >= 0 && age <= 150) { 
              this.age = age;
          }
      }
  }
  // 非法数据被拦截
  Person p = new Person();
  p.setAge(1200); // 赋值失败
  ```

**解析**：
从 “数据安全”“可维护性”“实现成本” 对比，突出封装在实际开发中解决的核心问题（数据混乱、耦合性高）。

1. **举例说明生活中的 “封装” 现象，如何对应到编程中的封装思想**
   **答案**：
   生活案例：**手机的 “拍照功能”**

- 生活中：我们点击 “拍照按钮” 就能拍照，无需了解 “摄像头调用、图像压缩、存储” 等内部细节（隐藏实现细节）；手机系统会校验 “是否授权摄像头、存储空间是否足够”（保护数据 / 功能安全 ）。
- 编程对应：
  把 “拍照逻辑” 封装成`Phone`类的`takePhoto()`方法（隐藏细节）；
  用`private`隐藏摄像头权限、存储路径等属性；
  通过`set`方法校验 “是否授权、空间是否足够”（如`setCameraPermission(boolean permission)` ），保证功能合法调用。

**解析**：
需找 “生活中隐藏内部逻辑、对外提供简单接口” 的案例，映射编程中 “属性隐藏 + 方法开放 + 逻辑校验” 的封装思想。

1. **子类继承父类时，父类封装的`private`属性对子类访问有什么影响？子类如何访问这些属性？**
   **答案**：

- 影响：子类**不能直接访问**父类的`private`属性（因为`private`修饰的成员仅限本类访问 ）。
- 访问方式：子类需通过父类提供的 **`public`或`protected`的`get/set`方法 ** 间接访问。

示例：

```java
class Parent {
    private String secret; // 父类private属性

    // 父类提供public的get方法
    public String getSecret() {
        return secret;
    }
}

class Child extends Parent {
    public void showParentSecret() {
        // 子类不能直接访问secret，需通过get方法
        System.out.println(getSecret()); 
    }
}
```

**解析**：
强调`private`的访问限制，以及子类通过父类开放的方法间接访问的逻辑。

1. **在`set`方法中，除了数据范围校验，还能添加哪些逻辑来保证数据安全？（至少举 2 例 ）**
   **答案**：
   可添加以下逻辑：

- **格式校验**：如姓名不能包含特殊字符、邮箱需符合`xxx@xxx.xxx`格式。
  示例（邮箱校验）：

  ```java
  public void setEmail(String email) {
      if (email.matches("^[\\w.-]+@[\\w.-]+\\.[a-z]{2,}$")) { 
          this.email = email;
      }
  }
  ```

- **依赖校验**：如 “设置学生年级” 时，需先设置 “学校” 属性（保证数据关联性 ）。
  示例：

  ```java
  private String school; 
  private int grade; 
  
  public void setGrade(int grade) {
      if (school != null) { // 依赖school已设置
          this.grade = grade;
      } else {
          System.out.println("请先设置学校！");
      }
  }
  ```

- **加密处理**：如设置密码时，对密码进行 MD5 加密存储（保护敏感数据 ）。
  示例（密码加密）：

  ```java
  public void setPassword(String pwd) {
      this.password = MD5Util.encrypt(pwd); // 加密后存储
  }
  ```

**解析**：
从 “格式、依赖、加密” 等角度扩展，体现`set`方法可灵活添加多样校验，保障数据安全。

1. **封装体现了面向对象编程的什么设计原则？简要解释**
   **答案**：
   封装体现了 **“高内聚、低耦合”** 原则：

- **高内聚**：类的 “数据（属性）” 和 “操作逻辑（方法）” 高度内聚（绑定）在一个类中，内部逻辑完整且独立。
- **低耦合**：类与外部的交互通过`get/set`等简单接口实现，减少外部对类内部的依赖。修改类内部逻辑（如改校验规则）时，不影响外部调用代码。

**解析**：
关联 “高内聚（内部逻辑集中）” 和 “低耦合（外部依赖少）”，说明封装如何让类的设计更合理。

1. **若要设计一个 “电商订单类（Order）”，包含订单金额、收货地址等属性，说明如何用封装设计，并说明每个步骤的考虑**
   **答案**：
   设计`Order`类，封装步骤及考虑：

- **① 私有化属性**：
  把敏感 / 需保护的属性设为`private`，如订单金额（`amount`）、收货地址（`address`）。
  考虑：防止外部直接修改金额（如恶意篡改订单价格）、地址（如乱改收货地 ）。
  代码：

  ```java
  public class Order {
      private double amount; // 订单金额
      private String address; // 收货地址
  }
  ```

- **② 写`set`方法（带校验）**：

  - `setAmount`：校验金额 > 0（订单金额不能为负 ）。
  - `setAddress`：校验地址非空、格式合理（如包含省市区 ）。
    考虑：保证订单数据合法，避免无效订单。
    代码：

  ```java
  public void setAmount(double amount) {
      if (amount > 0) { 
          this.amount = amount;
      } else {
          System.out.println("订单金额需大于0！");
      }
  }
  
  public void setAddress(String address) {
      if (address != null && address.contains("省") && address.contains("市")) { 
          this.address = address;
      } else {
          System.out.println("地址格式需包含省、市信息！");
      }
  }
  ```

- **③ 写`get`方法（开放读取）**：
  提供`getAmount`、`getAddress`方法，允许外部获取订单信息（如订单展示、物流系统读取地址 ）。
  考虑：按需开放数据访问，保证外部能合法获取必要信息。
  代码：

  ```java
  public double getAmount() {
      return amount;
  }
  
  public String getAddress() {
      return address;
  }
  ```

**解析**：
结合电商订单场景，说明每一步封装的 “实际需求驱动”（如金额防篡改、地址需合法），体现封装在业务中的价值。

## 五、编程题答案及解析

1. **`Person`类封装实现**
   **答案代码**：

   ```java
   public class Person {
       // 1. 私有化属性
       private String name;
       private int age;
   
       // 2. set方法（带校验）
       public void setName(String name) {
           if (name != null && !name.trim().isEmpty()) { // 姓名非空校验
               this.name = name;
           } else {
               System.out.println("姓名不能为空！");
           }
       }
   
       public void setAge(int age) {
           if (age >= 0 && age <= 150) { // 年龄范围校验
               this.age = age;
           } else {
               System.out.println("年龄需在0-150之间！");
           }
       }
   
       // 3. get方法（获取属性值）
       public String getName() {
           return name;
       }
   
       public int getAge() {
           return age;
       }
   }
   ```

   **解析**：

   - 通过`private`隐藏`name`和`age`，禁止外部直接修改；
   - `setName`校验姓名非空（去除首尾空格后判断），`setAge`限制年龄范围，避免非法数据；
   - `get`方法提供属性的合法访问途径，符合封装 “隐藏 + 开放” 的核心思想。

2. **`Student`类封装实现**
   **答案代码**：

   ```java
   public class Student {
       // 1. 私有化属性
       private String studentId;
       private int score;
   
       // 2. set方法（带处理和校验）
       public void setStudentId(String studentId) {
           if (studentId != null) {
               this.studentId = studentId.trim(); // 去除首尾空格
           } else {
               this.studentId = null;
           }
       }
   
       public void setScore(int score) {
           if (score >= 0 && score <= 100) { // 分数范围校验
               this.score = score;
           } else {
               System.out.println("分数需在0-100之间！");
           }
       }
   
       // 3. get方法
       public String getStudentId() {
           return studentId;
       }
   
       public int getScore() {
           return score;
       }
   }
   ```

   **解析**：

   - `studentId`的`set`方法通过`trim()`处理空格，保证学号格式整洁；
   - `score`的`set`方法校验 0-100 范围，符合学生成绩的业务逻辑；
   - 封装后，外部只能通过`set`方法间接修改属性，确保数据合法性。

3. **`BankAccount`类封装实现**
   **答案代码**：

   ```java
   public class BankAccount {
       // 1. 私有化属性（余额不允许直接修改）
       private double balance;
   
       // 2. 提供存款、取款方法（替代直接修改）
       public void deposit(double amount) {
           if (amount > 0) { // 存款金额需为正数
               balance += amount;
               System.out.println("存款成功，当前余额：" + balance);
           } else {
               System.out.println("存款金额必须大于0！");
           }
       }
   
       public void withdraw(double amount) {
           if (amount > 0) {
               if (amount <= balance) { // 校验余额是否足够
                   balance -= amount;
                   System.out.println("取款成功，当前余额：" + balance);
               } else {
                   System.out.println("余额不足，取款失败！");
               }
           } else {
               System.out.println("取款金额必须大于0！");
           }
       }
   
       // 3. get方法查看余额
       public double getBalance() {
           return balance;
       }
   }
   ```

   **解析**：

   - `balance`设为`private`，禁止外部直接增减，而是通过`deposit`和`withdraw`方法操作；
   - 方法中添加校验（如金额为正、取款不超过余额），模拟银行账户的安全逻辑；
   - 体现封装 “隐藏数据修改细节，通过特定方法控制操作” 的核心，保护资金安全。

4. **`Rectangle`类封装实现**
   **答案代码**：

   ```java
   public class Rectangle {
       // 1. 私有化属性
       private double width;
       private double height;
   
       // 2. set方法（校验宽高>0）
       public void setWidth(double width) {
           if (width > 0) {
               this.width = width;
           } else {
               System.out.println("宽度必须大于0！");
           }
       }
   
       public void setHeight(double height) {
           if (height > 0) {
               this.height = height;
           } else {
               System.out.println("高度必须大于0！");
           }
       }
   
       // 3. get方法
       public double getWidth() {
           return width;
       }
   
       public double getHeight() {
           return height;
       }
   
       // 隐藏面积计算逻辑
       public double getArea() {
           return width * height;
       }
   }
   ```

   **解析**：

   - 宽高通过`set`方法校验 “大于 0”，确保矩形的几何合理性；
   - `getArea`方法封装面积计算逻辑（宽 × 高），外部无需关心计算过程，只需调用方法即可获取结果；
   - 体现封装 “隐藏实现细节” 的好处，若后续修改面积公式（如添加单位转换），只需改动`getArea`方法，不影响外部调用。

5. **`User`类封装实现**
   **答案代码**：

   ```java
   public class User {
       // 1. 私有化属性
       private String username;
       private String password;
   
       // 2. set方法（长度校验）
       public void setUsername(String username) {
           if (username != null && username.length() >= 6 && username.length() <= 20) {
               this.username = username;
           } else {
               System.out.println("用户名长度需在6-20之间！");
           }
       }
   
       public void setPassword(String password) {
           if (password != null && password.length() >= 8) {
               this.password = password;
           } else {
               System.out.println("密码长度至少8位！");
           }
       }
   
       // 3. get方法
       public String getUsername() {
           return username;
       }
   
       public String getPassword() {
           return password;
       }
   }
   ```

   **解析**：

   - 用户名和密码通过`set`方法校验长度，符合用户注册的常见业务规则；
   - 封装后，外部无法设置不符合要求的账号密码，保证用户数据的规范性；
   - 若后续需修改规则（如密码需包含大写字母），只需扩展`setPassword`方法的校验逻辑，体现可维护性。

6. **`Product`类封装实现**
   **答案代码**：

   ```java
   public class Product {
       // 1. 私有化属性
       private String name;
       private double price;
       private int stock;
   
       // 2. set方法（各属性校验）
       public void setName(String name) {
           this.name = name; // 商品名不做严格限制，实际可根据需求添加（如非空）
       }
   
       public void setPrice(double price) {
           if (price > 0) {
               this.price = price;
           } else {
               System.out.println("价格必须大于0！");
           }
       }
   
       public void setStock(int stock) {
           if (stock >= 0) {
               this.stock = stock;
           } else {
               System.out.println("库存不能为负数！");
           }
       }
   
       // 3. get方法
       public String getName() {
           return name;
       }
   
       public double getPrice() {
           return price;
       }
   
       public int getStock() {
           return stock;
       }
   
       // 减少库存方法（带校验）
       public void reduceStock(int num) {
           if (num > 0) {
               if (num <= stock) {
                   stock -= num;
                   System.out.println("库存减少成功，当前库存：" + stock);
               } else {
                   System.out.println("库存不足，减少失败！");
               }
           } else {
               System.out.println("减少数量必须大于0！");
           }
       }
   }
   ```

   **解析**：

   - 价格（`price`）校验 “>0”，库存（`stock`）校验 “≥0”，符合商品的基本属性规则；
   - `reduceStock`方法封装库存减少逻辑，校验减少数量的合法性，避免库存出现负数；
   - 各方法职责单一，通过封装实现 “数据校验 + 操作控制”，保证商品信息的准确性。

7. **`Car`类封装实现**
   **答案代码**：

   ```java
   public class Car {
       // 1. 私有化属性
       private String brand;
       private int speed;
   
       // 2. set方法（处理和校验）
       public void setBrand(String brand) {
           if (brand != null && !brand.isEmpty()) {
               // 首字母大写处理（如"bmw"→"Bmw"）
               this.brand = brand.substring(0, 1).toUpperCase() + brand.substring(1).toLowerCase();
           } else {
               this.brand = brand;
           }
       }
   
       public void setSpeed(int speed) {
           if (speed >= 0 && speed <= 200) { // 时速范围校验
               this.speed = speed;
           } else {
               System.out.println("时速需在0-200之间！");
           }
       }
   
       // 3. get方法
       public String getBrand() {
           return brand;
       }
   
       public int getSpeed() {
           return speed;
       }
   }
   ```

   **解析**：

   - `setBrand`方法对品牌名进行格式化处理（首字母大写），保证数据格式统一；
   - 时速（`speed`）限制在 0-200，符合常见汽车的合理速度范围；
   - 通过封装自动处理数据格式，减少外部调用的繁琐操作，体现 “封装简化使用” 的优势。

8. **`ScoreRecord`类封装实现**
   **答案代码**：

   ```java
   public class ScoreRecord {
       // 1. 私有化属性
       private int mathScore;
       private int chineseScore;
   
       // 2. set方法（成绩范围校验）
       public void setMathScore(int mathScore) {
           if (mathScore >= 0 && mathScore <= 100) {
               this.mathScore = mathScore;
           } else {
               System.out.println("数学成绩需在0-100之间！");
           }
       }
   
       public void setChineseScore(int chineseScore) {
           if (chineseScore >= 0 && chineseScore <= 100) {
               this.chineseScore = chineseScore;
           } else {
               System.out.println("语文成绩需在0-100之间！");
           }
       }
   
       // 3. get方法
       public int getMathScore() {
           return mathScore;
       }
   
       public int getChineseScore() {
           return chineseScore;
       }
   
       // 隐藏总分计算逻辑
       public int getTotalScore() {
           return mathScore + chineseScore;
       }
   }
   ```

   **解析**：

   - 数学和语文成绩通过`set`方法校验 0-100 范围，符合考试成绩的常规规则；
   - `getTotalScore`方法封装总分计算逻辑（两科相加），外部无需手动计算，直接调用即可；
   - 若后续需修改总分规则（如加权计算），只需改动`getTotalScore`方法，外部调用代码不受影响，体现封装的可维护性。

9. **`Address`类封装实现**
   **答案代码**：

   ```java
   public class Address {
       // 1. 私有化属性
       private String province;
       private String city;
       private String detail;
   
       // 2. set方法（处理空格）
       public void setProvince(String province) {
           this.province = (province != null) ? province.trim() : null;
       }
   
       public void setCity(String city) {
           this.city = (city != null) ? city.trim() : null;
       }
   
       public void setDetail(String detail) {
           this.detail = detail;
       }
   
       // 3. get方法
       public String getProvince() {
           return province;
       }
   
       public String getCity() {
           return city;
       }
   
       public String getDetail() {
           return detail;
       }
   
       // 封装完整地址拼接逻辑
       public String getFullAddress() {
           return province + " " + city + " " + detail;
       }
   }
   ```

   **解析**：

   - 省份（`province`）和城市（`city`）的`set`方法通过`trim()`去除多余空格，保证地址整洁；
   - `getFullAddress`方法封装地址拼接逻辑（省 + 市 + 详细地址），外部无需关心拼接规则；
   - 封装后，地址的处理和拼接逻辑集中在类内部，便于统一维护和修改。

10. **`Temperature`类封装实现**
    **答案代码**：

    ```java
    public class Temperature {
        // 1. 私有化属性
        private double value;
    
        // 2. set方法（温度范围校验）
        public void setValue(double value) {
            if (value >= -273.15 && value <= 1000) { // 合理温度范围（-273.15为绝对零度）
                this.value = value;
            } else {
                System.out.println("温度需在-273.15到1000之间！");
            }
        }
    
        // 3. get方法
        public double getValue() {
            return value;
        }
    
        // 隐藏沸点判断逻辑（100℃）
        public boolean isBoiling() {
            return value >= 100;
        }
    }
    ```

    **解析**：

    - 温度值（`value`）校验范围为 - 273.15（绝对零度）到 1000℃，符合现实中温度的合理区间；
    - `isBoiling`方法封装 “是否达到沸点（≥100℃）” 的判断逻辑，外部直接调用即可获取结果；
    - 体现封装在 “科学数据处理” 中的应用：通过校验保证数据合理性，通过方法隐藏专业判断逻辑。